/**
* CHANGELOG:
*
* <ul>
* <li><b>1.0</b> - 2012-07-25 15:35</li>
*	<ul>
*		<li>Create file</li>
*	</ul>
* </ul>
* @author Piotr Paczkowski - kontakt@trzeci.eu
*/
package pl.asria.tools.data 
{
	import adobe.utils.CustomActions;
	import flash.errors.IllegalOperationError;
	import flash.utils.describeType;
	import flash.utils.Dictionary;
	import flash.utils.getDefinitionByName;
	import flash.utils.getQualifiedClassName;
	import flash.utils.getTimer;
	import pl.asria.tools.utils.getSuperClass;
	
	public class AbstractClass 
	{
		private static var __valided:Dictionary = new Dictionary(false);
		private static var __metaCollector:Dictionary = new Dictionary(false);
		private static var __className:String;
		{
			__className = getQualifiedClassName(AbstractClass);
		}
		/**
		 * AbstractClass - Some kind of Virtual Class in normal Objective language. Vitrual property over method is generated by [Abstract(name="someElementName")] metatag. name is required parameter. 
		 * @usage - 
		 
		 add metatag over class section
		 
		 [Abstract(name="someElementName", type="method")]
		 
		 // extra parameters
		 [Abstract(name="someElementName", type="method", argumentsLength="2")]
		 [Abstract(name="someElementName", type="method", returnType="void")]
		 [Abstract(name="someElementName", type="method", returnType="String")]
		 [Abstract(name="someElementName", type="method", arguments="String,?,String,*")] // ? is not deklarated element
		 
		 [Abstract(name="someElementName", type="accessor")]
		 // extra parameters
		 [Abstract(name="someElementName", type="accessor", access="readonly")]
		 [Abstract(name="someElementName", type="accessor", access="writeonly")]
		 [Abstract(name="someElementName", type="accessor", access="readwrite")]
		 
		 [Abstract(name="someElementName", type="variable")]
		 // extra parameters
		 [Abstract(name="someElementName", type="variable", varType="String")]
		 [Abstract(name="someElementName", type="variable", varType="*")]
		 
		 
		 
		 * @version - 1.0
		 * @author - Piotr Paczkowski - kontakt@trzeci.eu
		 */
		public function AbstractClass() 
		{
			if (__valided[(this as Object).constructor] !== true)
			{
				CONFIG::debug
				{
					var ts:uint = getTimer();
				}
				__validateOverXML();
				
				CONFIG::debug
				{
					trace("0:AbstractClass[" + this+ "] valid abstraction in:", (getTimer() - ts));
				}
			}
		}

		protected function __collectMeta(className:String, description:XML = null):Vector.<Object>
		{
			var result:Vector.<Object> = __metaCollector[className];
			if (result) return result;
			
			result = new Vector.<Object>()
			if (description == null) description = describeType(getDefinitionByName(className)).factory[0];
			
			for each (var meta:XML in description.metadata.(@name == "Abstract")) 
			{
				var definition:Object = { };
				for each (var arg:XML in meta.arg) 
				{
					definition[String(arg.@key)] = String(arg.@value);
				}
				result.push(definition);
			}
			
			if (description.extendsClass.length())
			{
				var extendsClass:String = description.extendsClass[0].@type;
				if (extendsClass != "Object")
				{
					
					result = result.concat(__collectMeta(extendsClass));
				}
			}
			result.fixed = true;
			__metaCollector[className] = result;
			return result;
			
		}
		
		private function __validateOverXML():void 
		{
			/**
			 * collect all meta:Abstract in chain
			 * compare meta requirement and true requirement
			 */
			// TODO: improve inheritable chain
			var description:XML = describeType(this);
			var requirement:Vector.<Object> = __collectMeta(getQualifiedClassName(this), description);
			
			var requiredMethods:Array = [];
			//for each (var virtualDefinition:XML in description.metadata.(@name == "Abstract")) 
			for each (var metaObject:Object in requirement) 
			{
				var nodes:XMLList;
				// param name is required
				var type:String = metaObject.type;
				var name:String = metaObject.name;
				var valided:Boolean = false;
				// check params
				switch(type)
				{
					case "accessor": 
					{
						nodes = description.accessor;
						if (!nodes.length()) break;
						
						nodes = nodes.(@name == name);
						if (!nodes.length()) break;
						
						if (metaObject["access"] != undefined)
						{
							nodes = nodes.(@access == access);
							if (!nodes.length()) break;
						}
						
						valided = true;
						break;
						
					}
					case "method": 
					{
						for each (var nodeDefinition:XML in description.method) 
						{
							if (nodeDefinition["@name"] == name)
							{
								valided = true;
								break;
							}
						}
						break;
					}
					case "variable":
					{
						for each (nodeDefinition in description.variable) 
						{
							if (nodeDefinition["@name"] == name)
							{
								valided = true;
								break;
							}
						}
						break;
					}
					default: 
					{
						trace("4:Unsupported abstract type definition:" + type + " for: " + this);
						break;
					}
				}
				
				if (!valided)
				{
					
					throw new IllegalOperationError("Invalid class definition in '" + description.@name + ". wrong implementation: " + type);
				}
			}
			__valided[(this as Object).constructor] = true;
		}
		
		
	}

}